import { NextResponse } from "next/server"
import { createClient } from "lib/supabase/server"

const MAX_RESULTS = 10
const MIN_QUERY_LENGTH = 2

const CACHE_TTL_MS = 60_000
const CACHE_MAX_ENTRIES = 500
type CacheEntry = {
  expiresAt: number
  results: ApiResult[]
}
const cache = new Map<string, CacheEntry>()

const pruneCache = () => {
  // Remove expired entries first.
  const now = Date.now()
  // Avoid TS2802 in downlevel builds by iterating an array snapshot.
  for (const [key, entry] of Array.from(cache.entries())) {
    if (entry.expiresAt <= now) {
      cache.delete(key)
    }
  }
  // Bound memory in long-lived runtimes.
  while (cache.size > CACHE_MAX_ENTRIES) {
    const firstKey = cache.keys().next().value as string | undefined
    if (!firstKey) break
    cache.delete(firstKey)
  }
}

type ApiResult = {
  id: number
  street: string
  locality: string
  localityId?: number
  ta: string | null
  lat: number
  lng: number
  displayName: string
}

function disambiguateByDisplayName(results: ApiResult[]): ApiResult[] {
  const groups = new Map<string, ApiResult[]>()

  for (const r of results) {
    const key = r.displayName.trim().toLowerCase()
    const existing = groups.get(key)
    if (existing) {
      existing.push(r)
    } else {
      groups.set(key, [r])
    }
  }

  groups.forEach((group) => {
    if (group.length <= 1) return

    const suffixCounts = new Map<string, number>()
    for (const r of group) {
      const suffix = (r.ta ?? "").trim() || `Locality ${r.localityId ?? r.id}`
      suffixCounts.set(suffix, (suffixCounts.get(suffix) ?? 0) + 1)
    }

    for (const r of group) {
      const base = r.displayName
      const rawSuffix = (r.ta ?? "").trim() || `Locality ${r.localityId ?? r.id}`
      const needsMore =
        (suffixCounts.get(rawSuffix) ?? 0) > 1 && r.localityId !== undefined
      const suffix = needsMore ? `${rawSuffix} Â· ${r.localityId}` : rawSuffix
      r.displayName = `${base} (${suffix})`
    }
  })

  return results
}

type LocalityCoords = { lat: number; lng: number }
let localityCoordsByLinzId: Map<number, LocalityCoords> | null = null
let localityCoordsPromise: Promise<Map<number, LocalityCoords>> | null = null

async function loadLocalityCoordsByLinzId(): Promise<Map<number, LocalityCoords>> {
  if (localityCoordsByLinzId) return localityCoordsByLinzId
  if (localityCoordsPromise) return localityCoordsPromise

  // Load from the public JSON (generated by scripts/build-nz-localities.mjs).
  localityCoordsPromise = (async () => {
    try {
      // Next's JSON module typing doesn't always align with our actual data shape.
      // Cast through `unknown` to make the intent explicit and keep type-safety at usage.
      const jsonModule = (await import("../../../../public/data/nz-localities.min.json")) as unknown as {
        default?: { records?: Array<[string, number, number, number?]> }
      }
      const data = (jsonModule.default ?? {}) as { records?: Array<[string, number, number, number?]> }
      const map = new Map<number, LocalityCoords>()
      for (const record of data.records ?? []) {
        if (!Array.isArray(record) || record.length < 3) continue
        const lat = record[1]
        const lng = record[2]
        const linzId = record[3]
        if (typeof lat === "number" && typeof lng === "number" && typeof linzId === "number") {
          map.set(linzId, { lat, lng })
        }
      }
      localityCoordsByLinzId = map
      return map
    } catch {
      // If the JSON isn't available (or bundling disallows require), fall back to an empty map.
      localityCoordsByLinzId = new Map()
      return localityCoordsByLinzId
    } finally {
      // best-effort: ensure promise doesn't stick around after resolve
      localityCoordsPromise = null
    }
  })()

  return localityCoordsPromise
}

const ADDRESS_FINDER_BASE =
  "https://services.arcgis.com/xdsHIIxuCWByZiCB/ArcGIS/rest/services/Addresses_StatsNZ_AddressFinder/FeatureServer/0/query"

const escapeSqlLike = (value: string) =>
  value
    .replace(/\\/g, "") // Remove backslashes
    .replace(/[%_]/g, "") // Remove LIKE wildcards
    .replace(/'/g, "''") // Escape single quotes

async function searchAddressFinder({
  q,
  locality,
}: {
  q: string
  locality: string | null
}): Promise<ApiResult[]> {
  const qClean = escapeSqlLike(q.trim())
  if (qClean.length < MIN_QUERY_LENGTH) return []

  // Use UPPER() for case-insensitive search in ArcGIS SQL
  const clauses = [`UPPER(road_name) LIKE UPPER('%${qClean}%')`]
  if (locality) {
    const locClean = escapeSqlLike(locality.trim())
    if (locClean) {
      clauses.push(`(UPPER(suburb_locality) LIKE UPPER('${locClean}%') OR UPPER(town_city) LIKE UPPER('${locClean}%'))`)
    }
  }
  const where = clauses.join(" AND ")

  const params = new URLSearchParams({
    where,
    outFields: "fid,road_name,suburb_locality,town_city,ta_name,address_id",
    returnGeometry: "true",
    outSR: "4326",
    resultRecordCount: String(MAX_RESULTS * 5), // we'll de-dupe client-side
    f: "json",
  })

  const response = await fetch(`${ADDRESS_FINDER_BASE}?${params.toString()}`, {
    // Keep it fast/cheap. This data is public and changes rarely.
    next: { revalidate: 60 },
  } as RequestInit)
  if (!response.ok) return []
  const data = (await response.json()) as {
    features?: Array<{
      attributes?: Record<string, unknown>
      geometry?: { x?: number; y?: number }
    }>
  }
  const features = Array.isArray(data.features) ? data.features : []

  const results: ApiResult[] = []
  const seen = new Set<string>()
  for (const feature of features) {
    const attrs = feature.attributes ?? {}
    const road = typeof attrs.road_name === "string" ? attrs.road_name.trim() : ""
    if (!road) continue
    const suburbLocality =
      typeof attrs.suburb_locality === "string" ? attrs.suburb_locality.trim() : ""
    const townCity = typeof attrs.town_city === "string" ? attrs.town_city.trim() : ""
    const localityName = suburbLocality || townCity
    if (!localityName) continue

    const geom = feature.geometry
    const lng = typeof geom?.x === "number" ? geom.x : null
    const lat = typeof geom?.y === "number" ? geom.y : null
    if (lat === null || lng === null) continue

    const key = `${road.toLowerCase()}|${localityName.toLowerCase()}`
    if (seen.has(key)) continue
    seen.add(key)

    const idRaw = attrs.address_id ?? attrs.fid
    const id = typeof idRaw === "number" ? idRaw : results.length + 1
    const ta = typeof attrs.ta_name === "string" ? attrs.ta_name : null
    results.push({
      id,
      street: road,
      locality: localityName,
      ta,
      lat,
      lng,
      displayName: `${road}, ${localityName}`,
    })
    if (results.length >= MAX_RESULTS) break
  }

  return results
}

export async function GET(request: Request) {
  const url = new URL(request.url)
  const query = url.searchParams.get("q")?.trim()
  const localityParam = url.searchParams.get("locality")?.trim()
  // Allow partial locality input (e.g. "Rollest") by using prefix matching.
  const locality =
    localityParam && localityParam.length > 0
      ? localityParam.replace(/[%_]/g, "")
      : null
  const localityIdParam = url.searchParams.get("localityId")?.trim()
  const localityId = localityIdParam && /^[0-9]+$/.test(localityIdParam) ? Number(localityIdParam) : null

  if (!query || query.length < MIN_QUERY_LENGTH) {
    return NextResponse.json({ results: [] }, { headers: { "Cache-Control": "public, s-maxage=60" } })
  }

  pruneCache()
  const cacheKey = JSON.stringify({
    q: query,
    locality: locality ?? null,
    localityId,
  })
  const cached = cache.get(cacheKey)
  if (cached && cached.expiresAt > Date.now()) {
    return NextResponse.json(
      { results: cached.results },
      {
        headers: {
          "Cache-Control": "public, s-maxage=60, stale-while-revalidate=300",
        },
      }
    )
  }

  const returnWithCache = (results: ApiResult[]) => {
    cache.set(cacheKey, { expiresAt: Date.now() + CACHE_TTL_MS, results })
    return NextResponse.json(
      { results },
      {
        headers: {
          "Cache-Control": "public, s-maxage=60, stale-while-revalidate=300",
        },
      }
    )
  }

  // If Supabase isn't reachable / tables aren't ready in production yet,
  // keep the UX working by falling back to the public AddressFinder API.
  let supabase: Awaited<ReturnType<typeof createClient>> | null = null
  try {
    supabase = await createClient()
  } catch (error) {
    console.error("Address search error (supabase client):", error)
    const fallbackResults = await searchAddressFinder({ q: query, locality })
    return returnWithCache(fallbackResults)
  }

  if (!supabase) {
    const fallbackResults = await searchAddressFinder({ q: query, locality })
    return returnWithCache(fallbackResults)
  }

  // Single source of truth: `nz_road_names` (road_name + locality FK).
  let roadQuery = supabase
    .from("nz_road_names")
    .select("id, road_name, locality_name, locality_linz_id, ta, display_name")
    .or(`road_name.ilike.%${query}%,display_name.ilike.%${query}%`)
    .order("road_name")
    .limit(MAX_RESULTS)

  if (localityId !== null) {
    roadQuery = roadQuery.eq("locality_linz_id", localityId)
  } else if (locality) {
    roadQuery = roadQuery.ilike("locality_name", `${locality}%`)
  }

  const { data: roads, error: roadError } = await roadQuery
  if (roadError) {
    console.error("Address search error (nz_road_names):", roadError)
    const fallbackResults = await searchAddressFinder({ q: query, locality })
    return returnWithCache(fallbackResults)
  }

  // If the table exists but isn't populated yet, fall back to the public
  // AddressFinder API to maintain UX.
  if (!roads || roads.length === 0) {
    const fallbackResults = await searchAddressFinder({ q: query, locality })
    return returnWithCache(fallbackResults)
  }

  const localityIds = Array.from(
    new Set((roads || []).map((r) => r.locality_linz_id).filter((id) => typeof id === "number"))
  ) as number[]

  const { data: localities, error: localityError } = localityIds.length
    ? await supabase
        .from("nz_localities")
        .select("linz_id, lat, lng")
        .in("linz_id", localityIds)
    : { data: [], error: null }

  if (localityError) {
    // If the localities table isn't present in local dev, derive coords from the
    // generated public JSON lookup instead.
    if (localityError.code === "PGRST205") {
      const coordsMap = await loadLocalityCoordsByLinzId()
      const results: ApiResult[] = (roads || []).flatMap((row) => {
        const coords = coordsMap.get(row.locality_linz_id)
        if (!coords) return []
        return [
          {
            id: row.id,
            street: row.road_name,
            locality: row.locality_name,
            localityId: row.locality_linz_id,
            ta: row.ta,
            lat: coords.lat,
            lng: coords.lng,
            displayName: row.display_name,
          },
        ]
      })

      const finalResults = disambiguateByDisplayName(results)
      return returnWithCache(finalResults)
    }

    console.error("Address search error (nz_localities):", localityError)
    const fallbackResults = await searchAddressFinder({ q: query, locality })
    return returnWithCache(fallbackResults)
  }

  const localityMap = new Map(
    (localities || []).map((l) => [l.linz_id, { lat: l.lat, lng: l.lng }] as const)
  )

  const results: ApiResult[] = (roads || []).flatMap((row) => {
    const coords = localityMap.get(row.locality_linz_id)
    if (!coords) return []
    return [
      {
        id: row.id,
        street: row.road_name,
        locality: row.locality_name,
        localityId: row.locality_linz_id,
        ta: row.ta,
        lat: coords.lat,
        lng: coords.lng,
        displayName: row.display_name,
      },
    ]
  })

  const finalResults = disambiguateByDisplayName(results)
  return returnWithCache(finalResults)
}
